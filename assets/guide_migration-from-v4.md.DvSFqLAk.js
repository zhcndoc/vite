import{_ as i,c as s,o as a,aq as t}from"./chunks/framework.CYFbgU53.js";const k=JSON.parse('{"title":"从 v4 迁移","description":"","frontmatter":{"head":[["link",{"rel":"canonical","href":"https://vite.zhcndoc.com/guide/migration-from-v4"}],["meta",{"property":"og:title","content":"从 v4 迁移"}]]},"headers":[],"relativePath":"guide/migration-from-v4.md","filePath":"guide/migration-from-v4.md"}'),l={name:"guide/migration-from-v4.md"};function o(n,e,r,d,h,p){return a(),s("div",null,[...e[0]||(e[0]=[t(`<h1 id="migration-from-v4" tabindex="-1">从 v4 迁移 <a class="header-anchor" href="#migration-from-v4" aria-label="Permalink to “从 v4 迁移”">​</a></h1><h2 id="nodejs-support" tabindex="-1">Node.js 支持 <a class="header-anchor" href="#nodejs-support" aria-label="Permalink to “Node.js 支持”">​</a></h2><p>Vite 不再支持 Node.js 14 / 16 / 17 / 19，因为它们已经到了 EOL。现在需要 Node.js 18 / 20+。</p><p>Some internal APIs have been removed due to changes in Vite&#39;s implementation. If you were relying on one of them, please create a <a href="https://github.com/vitejs/vite/issues/new?assignees=&amp;labels=enhancement%3A+pending+triage&amp;projects=&amp;template=feature_request.yml" target="_blank" rel="noreferrer">feature request</a>.</p><p>Vite 现在使用 Rollup 4，它也带来了一些重大的变化，特别是：</p><ul><li>导入断言（<code>assertions</code> 属性）已被重命名为导入属性（<code>attributes</code> 属性）。</li><li>不再支持 Acorn 插件。</li><li>对于 Vite 插件，<code>this.resolve</code> 的 <code>skipSelf</code> 选项现在默认为 <code>true</code>。</li><li>对于 Vite 插件，<code>this.parse</code> 现在只支持 <code>allowReturnOutsideFunction</code> 选项。</li></ul><p>你可以阅读 <a href="https://github.com/rollup/rollup/releases/tag/v4.0.0" target="_blank" rel="noreferrer">Rollup 的发布说明</a> 中的破坏性变更，了解在 <a href="/config/build-options.html#build-rollupoptions"><code>build.rollupOptions</code></a> 中构建相关的变更。</p><p>如果你正在使用 TypeScript，请确保设置 <code>moduleResolution: &#39;bundler&#39;</code>（或 <code>node16</code>/<code>nodenext</code>）因为 Rollup 4 需要它。或者你可以设置 <code>skipLibCheck: true</code>。</p><h2 id="deprecate-cjs-node-api" tabindex="-1">废弃 CJS Node API <a class="header-anchor" href="#deprecate-cjs-node-api" aria-label="Permalink to “废弃 CJS Node API”">​</a></h2><p>CJS 的 Node API 已经被废弃。当调用 <code>require(&#39;vite&#39;)</code> 时，将会记录一个废弃警告。你应该更新你的文件或框架来导入 Vite 的 ESM 构建。</p><p>在一个基础的 Vite 项目中，请确保：</p><ol><li><code>vite.config.js</code> 配置文件的内容使用 ESM 语法。</li><li>最近的 <code>package.json</code> 文件中有 <code>&quot;type&quot;: &quot;module&quot;</code>，或者使用 <code>.mjs</code>/<code>.mts</code> 扩展名，例如 <code>vite.config.mjs</code> 或者 <code>.vite.config.mts</code>。</li></ol><p>对于其他项目，有几种常见的方法：</p><ul><li><strong>配置 ESM 为默认，如果需要则选择 CJS：</strong> 在项目 <code>package.json</code> 中添加 <code>&quot;type&quot;: &quot;module&quot;</code>。所有 <code>*.js</code> 文件现在都被解释为 ESM，并且需要使用 ESM 语法。你可以将一个文件重命名为 <code>.cjs</code> 扩展名来继续使用 CJS。</li><li><strong>保持 CJS 为默认，如果需要则选择 ESM：</strong> 如果项目 <code>package.json</code> 没有 <code>&quot;type&quot;: &quot;module&quot;</code>，所有 <code>*.js</code> 文件都被解释为 CJS。你可以将一个文件重命名为 <code>.mjs</code> 扩展名来使用 ESM。</li><li><strong>动态导入 Vite：</strong> 如果你需要继续使用 CJS，你可以使用 <code>import(&#39;vite&#39;)</code> 动态导入 Vite。这要求你的代码必须在一个 <code>async</code> 上下文中编写，但是由于 Vite 的 API 大多是异步的，所以应该还是可以管理的。</li></ul><p>查看 <a href="/guide/troubleshooting.html#vite-cjs-node-api-deprecated">排错指南</a> 获取更多信息。</p><h2 id="rework-define-and-import-meta-env-replacement-strategy" tabindex="-1">重新设计 <code>define</code> 和 <code>import.meta.env.*</code> 的替换策略 <a class="header-anchor" href="#rework-define-and-import-meta-env-replacement-strategy" aria-label="Permalink to “重新设计 define 和 import.meta.env.* 的替换策略”">​</a></h2><p>在 Vite 4 中，<a href="/config/shared-options.html#define"><code>define</code></a> 和 <a href="/guide/env-and-mode.html#env-variables"><code>import.meta.env.*</code></a> 特性在开发和构建中使用的是不同的替换策略：</p><ul><li>在开发时，这两个特性分别作为全局变量注入到 <code>globalThis</code> 和 <code>import.meta</code> 中。</li><li>在构建时，这两个特性都使用正则表达式进行静态替换。</li></ul><p>这导致在尝试访问这些变量时，开发和构建存在一致性问题，有时甚至导致构建失败。例如：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// vite.config.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  define: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    __APP_VERSION__: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stringify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;1.0.0&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { __APP_VERSION__ }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 开发：{ __APP_VERSION__: &quot;1.0.0&quot; } ✅</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 构建：{ &quot;1.0.0&quot; } ❌</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> docs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;I like import.meta.env.MODE&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 开发：&quot;I like import.meta.env.MODE&quot; ✅</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 构建：&quot;I like &quot;production&quot;&quot; ❌</span></span></code></pre></div><p>Vite 5 通过在构建中使用 <code>esbuild</code> 来处理替换，使其与开发行为保持一致。</p><p>这个改动不应该影响大部分设置，因为已经在文档中说明了 <code>define</code> 的值应该遵循 esbuild 的语法：</p><blockquote><p>为了与 esbuild 行为保持一致，表达式必须是一个 JSON 对象（null、boolean、number、string、array 或 object）或一个单一标识符字符串。</p></blockquote><p>然而，如果你更喜欢对值直接使用静态替换，你可以使用 <a href="https://github.com/rollup/plugins/tree/master/packages/replace" target="_blank" rel="noreferrer"><code>@rollup/plugin-replace</code></a>。</p><h2 id="general-changes" tabindex="-1">其他一般性变化 <a class="header-anchor" href="#general-changes" aria-label="Permalink to “其他一般性变化”">​</a></h2><h3 id="ssr-externalized-modules-value-now-matches-production" tabindex="-1">SSR 外部模块值现在符合生产环境行为 <a class="header-anchor" href="#ssr-externalized-modules-value-now-matches-production" aria-label="Permalink to “SSR 外部模块值现在符合生产环境行为”">​</a></h3><p>在 Vite 4 中，服务端渲染的外部模块被包装为 <code>.default</code> 和 <code>.__esModule</code> 处理，以实现更好的互操作性，但是它并不符合运行时环境（例如 Node.js）加载时的生产环境行为，导致难以捕获的不一致性。默认情况下，所有直接的项目依赖都是 SSR 外部化的。</p><p>Vite 5 现在删除了 <code>.default</code> 和 <code>.__esModule</code> 处理，以匹配生产环境行为。在实践中，这不应影响正确打包的依赖项，但是如果你在加载模块时遇到新的问题，你可以尝试以下重构：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 之前：</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { foo } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;bar&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 之后：</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _bar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;bar&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _bar</span></span></code></pre></div><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 之前：</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;bar&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 之后：</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;bar&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _foo.default</span></span></code></pre></div><p>注意，这些更改符合 Node.js 的行为，因此也可以在 Node.js 中运行这些导入进行测试。如果你更喜欢坚持使用之前的方式，你可以将 <code>legacy.proxySsrExternalModules</code> 设置为 <code>true</code>。</p><h3 id="worker-plugins-is-now-a-function" tabindex="-1"><code>worker.plugins</code> 现在是一个函数 <a class="header-anchor" href="#worker-plugins-is-now-a-function" aria-label="Permalink to “worker.plugins 现在是一个函数”">​</a></h3><p>在 Vite 4 中，<a href="/config/worker-options.html#worker-plugins"><code>worker.plugins</code></a> 接受一个插件数组 (<code>(Plugin | Plugin[])[]</code>)。从 Vite 5 开始，它需要配置为一个返回插件数组的函数 (<code>() =&gt; (Plugin | Plugin[])[]</code>)。这个改变是为了让并行的 worker 构建运行得更加一致和可预测。</p><h3 id="allow-path-containing-to-fallback-to-index-html" tabindex="-1">允许路径包含 <code>.</code> 回退到 index.html <a class="header-anchor" href="#allow-path-containing-to-fallback-to-index-html" aria-label="Permalink to “允许路径包含 . 回退到 index.html”">​</a></h3><p>在 Vite 4 中，即使 <a href="/config/shared-options.html#apptype"><code>appType</code></a> 被设置为 <code>&#39;SPA&#39;</code>（默认），访问包含 <code>.</code> 的路径也不会回退到 index.html。从 Vite 5 开始，它将会回退到 index.html。</p><p>注意浏览器将不再在控制台中显示 404 错误消息，如果你将图片路径指向一个不存在的文件（例如 <code>&lt;img src=&quot;./file-does-not-exist.png&quot;&gt;</code>）。</p><h3 id="align-dev-and-preview-html-serving-behaviour" tabindex="-1">Align dev and preview HTML serving behaviour <a class="header-anchor" href="#align-dev-and-preview-html-serving-behaviour" aria-label="Permalink to “Align dev and preview HTML serving behaviour”">​</a></h3><p>在 Vite 4 中，开发服务器和预览服务器会根据 HTML 的目录结构和尾部斜杠的不同来提供 HTML。这会导致在测试构建后的应用时出现不一致的情况。Vite 5 重构成了一个单一的行为，如下所示，给定以下文件结构：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>├── index.html</span></span>
<span class="line"><span>├── file.html</span></span>
<span class="line"><span>└── dir</span></span>
<span class="line"><span>    └── index.html</span></span></code></pre></div><table tabindex="0"><thead><tr><th>请求</th><th>过往版本 (dev)</th><th>过往版本 (preview)</th><th>现在 (dev &amp; preview)</th></tr></thead><tbody><tr><td><code>/dir/index.html</code></td><td><code>/dir/index.html</code></td><td><code>/dir/index.html</code></td><td><code>/dir/index.html</code></td></tr><tr><td><code>/dir</code></td><td><code>/index.html</code> (SPA fallback)</td><td><code>/dir/index.html</code></td><td><code>/index.html</code> (SPA fallback)</td></tr><tr><td><code>/dir/</code></td><td><code>/dir/index.html</code></td><td><code>/dir/index.html</code></td><td><code>/dir/index.html</code></td></tr><tr><td><code>/file.html</code></td><td><code>/file.html</code></td><td><code>/file.html</code></td><td><code>/file.html</code></td></tr><tr><td><code>/file</code></td><td><code>/index.html</code> (SPA fallback)</td><td><code>/file.html</code></td><td><code>/file.html</code></td></tr><tr><td><code>/file/</code></td><td><code>/index.html</code> (SPA fallback)</td><td><code>/file.html</code></td><td><code>/index.html</code> (SPA fallback)</td></tr></tbody></table><h3 id="manifest-files-are-now-generated-in-vite-directory-by-default" tabindex="-1">Manifest 文件现在默认生成到 <code>.vite</code> 目录中 <a class="header-anchor" href="#manifest-files-are-now-generated-in-vite-directory-by-default" aria-label="Permalink to “Manifest 文件现在默认生成到 .vite 目录中”">​</a></h3><p>在 Vite 4 中，manifest 文件（<a href="/config/build-options.html#build-manifest"><code>build.manifest</code></a>，<a href="/config/build-options.html#build-ssrmanifest"><code>build.ssrManifest</code></a>）默认会生成在 <a href="/config/build-options.html#build-outdir"><code>build.outDir</code></a> 的根目录中。</p><p>从 Vite 5 开始，这些文件将默认生成在 <code>build.outDir</code> 中的 <code>.vite</code> 目录中。这个改变有助于解决当公共文件被复制到 <code>build.outDir</code> 时，具有相同 manifest 文件名时的冲突。</p><h3 id="corresponding-css-files-are-not-listed-as-top-level-entry-in-manifest-json-file" tabindex="-1">对应的 CSS 文件未在 manifest.json 文件中作为顶级入口列出 <a class="header-anchor" href="#corresponding-css-files-are-not-listed-as-top-level-entry-in-manifest-json-file" aria-label="Permalink to “对应的 CSS 文件未在 manifest.json 文件中作为顶级入口列出”">​</a></h3><p>在 Vite 4 中，JavaScript 入口起点的对应 CSS 文件也被列为了 manifest 文件的顶级入口（<a href="/config/build-options.html#build-manifest"><code>build.manifest</code></a>）。这些条目是非故意添加的，仅对简单情况有效。</p><p>在 Vite 5 中，对应的 CSS 文件只能在 JavaScript 入口起点中找到。 在注入 JS 文件时，对应的 CSS 文件 <a href="/guide/backend-integration.html#text-if-production-link-rel-3d-stylesheet-href-3d-assets-manifest-main-js-css-script-type-3d-module-src-3d-assets-manifest-main-js-file-script">应被注入</a>。 当需要单独注入 CSS 时，必需将其添加为单独的入口起点。</p><h3 id="cli-shortcuts-require-an-additional-enter-press" tabindex="-1">CLI 快捷功能键需要一个额外的 <code>Enter</code> 按键 <a class="header-anchor" href="#cli-shortcuts-require-an-additional-enter-press" aria-label="Permalink to “CLI 快捷功能键需要一个额外的 Enter 按键”">​</a></h3><p>CLI 快捷功能键，例如 <code>r</code> 重启开发服务器，现在需要额外的 <code>Enter</code> 按键来触发快捷功能。例如，<code>r + Enter</code> 重启开发服务器。</p><p>这个改动防止 Vite 吞噬和控制操作系统特定的快捷键，允许更好的兼容性，当将 Vite 开发服务器与其他进程结合使用时，并避免了<a href="https://github.com/vitejs/vite/pull/14342" target="_blank" rel="noreferrer">之前的注意事项</a>。</p><h3 id="update-experimentaldecorators-and-usedefineforclassfields-typescript-behaviour" tabindex="-1">Update <code>experimentalDecorators</code> and <code>useDefineForClassFields</code> TypeScript behaviour <a class="header-anchor" href="#update-experimentaldecorators-and-usedefineforclassfields-typescript-behaviour" aria-label="Permalink to “Update experimentalDecorators and useDefineForClassFields TypeScript behaviour”">​</a></h3><p>Vite 5 使用 esbuild 0.19 并移除了 esbuild 0.18 的兼容层，这改变了 <a href="https://www.typescriptlang.org/tsconfig#experimentalDecorators" target="_blank" rel="noreferrer"><code>experimentalDecorators</code></a> 和 <a href="https://www.typescriptlang.org/tsconfig#useDefineForClassFields" target="_blank" rel="noreferrer"><code>useDefineForClassFields</code></a> 的处理方式。</p><ul><li><p><strong><code>useDefineForClassFields</code> 默认不启用</strong></p><p>你需要在 <code>tsconfig.json</code> 中设置 <code>compilerOptions.experimentalDecorators</code> 为 <code>true</code> 来使用装饰器。</p></li><li><p><strong><code>useDefineForClassFields</code> 默认依赖 TypeScript 的 <code>target</code> 值</strong></p><p>如果 <code>target</code> 不是 <code>ESNext</code> 或 <code>ES2022</code> 或更新的版本，或者没有 <code>tsconfig.json</code> 文件，<code>useDefineForClassFields</code> 将默认为 <code>false</code>，这可能会导致默认的 <code>esbuild.target</code> 值 <code>esnext</code> 出现问题。它可能会转译为<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks#browser_compatibility" target="_blank" rel="noreferrer">静态初始化块</a>，这在你的浏览器中可能不被支持。</p><p>因此，建议在配置 <code>tsconfig.json</code> 时将 <code>target</code> 设置为 <code>ESNext</code> 或 <code>ES2022</code> 或更新的版本，或者将 <code>useDefineForClassFields</code> 显式地设置为 <code>true</code>。</p></li></ul><div class="language-jsonc"><button title="Copy Code" class="copy"></button><span class="lang">jsonc</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;compilerOptions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 若要使用装饰器就设为 true</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;experimentalDecorators&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 如果你在浏览器中看到解析错误，请设置为 true</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;useDefineForClassFields&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="remove-https-flag-and-https-true" tabindex="-1">移除 <code>--https</code> 标志和 <code>https: true</code> <a class="header-anchor" href="#remove-https-flag-and-https-true" aria-label="Permalink to “移除 --https 标志和 https: true”">​</a></h3><p><code>--https</code> 标志会在内部设置 <code>server.https: true</code> 和 <code>preview.https: true</code>。这个配置本来是为了与自动 https 证书生成功能一起使用的，但是这个功能在<a href="https://v3.vitejs.dev/guide/migration.html#automatic-https-certificate-generation" target="_blank" rel="noreferrer">Vite 3 中被移除</a>。因此，这个配置已经不再有用，因为它会启动一个没有证书的 Vite HTTPS 服务器。</p><p>如果你使用 <a href="https://github.com/vitejs/vite-plugin-basic-ssl" target="_blank" rel="noreferrer"><code>@vitejs/plugin-basic-ssl</code></a> 或者 <a href="https://github.com/liuweiGL/vite-plugin-mkcert" target="_blank" rel="noreferrer"><code>vite-plugin-mkcert</code></a>，它们已经在内部设置了 <code>https</code> 配置，所以你可以在你的设置中移除 <code>--https</code>，<code>server.https: true</code>，和<code>preview.https: true</code>。</p><h3 id="remove-resolvepackageentry-and-resolvepackagedata-apis" tabindex="-1">移除 <code>resolvePackageEntry</code> 和 <code>resolvePackageData</code> API <a class="header-anchor" href="#remove-resolvepackageentry-and-resolvepackagedata-apis" aria-label="Permalink to “移除 resolvePackageEntry 和 resolvePackageData API”">​</a></h3><p><code>resolvePackageEntry</code> 和 <code>resolvePackageData</code> API 已被移除，因为它们暴露了 Vite 的内部机制，并在过去阻碍了 Vite 4.3 的潜在优化。这些 API 可以被第三方包替代，例如：</p><ul><li><code>resolvePackageEntry</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta/resolve" target="_blank" rel="noreferrer"><code>import.meta.resolve</code></a> 或者 <a href="https://github.com/wooorm/import-meta-resolve" target="_blank" rel="noreferrer"><code>import-meta-resolve</code></a> 库。</li><li><code>resolvePackageData</code>: 与上述相同，向上爬取包目录以获取根 <code>package.json</code>。或者使用社区的 <a href="https://github.com/svitejs/vitefu" target="_blank" rel="noreferrer"><code>vitefu</code></a> 库。</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { resolve } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;import-meta-resolve&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { findDepPkgJsonPath } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vitefu&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;node:fs&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> pkg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;my-lib&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> basedir</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> process.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cwd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// \`resolvePackageEntry\`:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> packageEntry</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pkg, basedir)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// \`resolvePackageData\`:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> packageJsonPath</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> findDepPkgJsonPath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pkg, basedir)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> packageJson</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(packageJsonPath, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf-8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><h2 id="removed-deprecated-apis" tabindex="-1">移除部分废弃 API <a class="header-anchor" href="#removed-deprecated-apis" aria-label="Permalink to “移除部分废弃 API”">​</a></h2><ul><li>CSS 文件的默认导出（例如 <code>import style from &#39;./foo.css&#39;</code>）：使用 <code>?inline</code> 查询参数代替</li><li><code>import.meta.globEager</code>：使用 <code>import.meta.glob(&#39;*&#39;, { eager: true })</code> 来代替</li><li><code>ssr.format: &#39;cjs&#39;</code> 和 <code>legacy.buildSsrCjsExternalHeuristics</code>（<a href="https://github.com/vitejs/vite/discussions/13816" target="_blank" rel="noreferrer">#13816</a>）</li><li><code>server.middlewareMode: &#39;ssr&#39;</code> 和 <code>server.middlewareMode: &#39;html&#39;</code>：使用 <a href="/config/shared-options.html#apptype"><code>appType</code></a> + <a href="/config/server-options.html#server-middlewaremode"><code>server.middlewareMode: true</code></a> 来代替（<a href="https://github.com/vitejs/vite/pull/8452" target="_blank" rel="noreferrer">#8452</a>）</li></ul><h2 id="advanced" tabindex="-1">进阶 <a class="header-anchor" href="#advanced" aria-label="Permalink to “进阶”">​</a></h2><p>下列改动仅会影响到插件/工具的作者：</p><ul><li><a href="https://github.com/vitejs/vite/pull/14119" target="_blank" rel="noreferrer">[#14119] refactor!: merge <code>PreviewServerForHook</code> into <code>PreviewServer</code> type</a><ul><li>The <code>configurePreviewServer</code> hook now accepts the <code>PreviewServer</code> type instead of <code>PreviewServerForHook</code> type.</li></ul></li><li><a href="https://github.com/vitejs/vite/pull/14818" target="_blank" rel="noreferrer">[#14818] refactor(preview)!: use base middleware</a><ul><li>Middlewares added from the returned function in <code>configurePreviewServer</code> now does not have access to the <code>base</code> when comparing the <code>req.url</code> value. This aligns the behaviour with the dev server. You can check the <code>base</code> from the <code>configResolved</code> hook if needed.</li></ul></li><li><a href="https://github.com/vitejs/vite/pull/14834" target="_blank" rel="noreferrer">[#14834] fix(types)!: expose httpServer with Http2SecureServer union</a><ul><li><code>http.Server | http2.Http2SecureServer</code> is now used instead of <code>http.Server</code> where appropriate.</li></ul></li></ul><p>此外，还有其他一些只影响少数用户的破坏性变化。</p><ul><li><a href="https://github.com/vitejs/vite/pull/14098" target="_blank" rel="noreferrer">[#14098] fix!: avoid rewriting this (reverts #5312)</a><ul><li>之前顶层 <code>this</code> 将会在构建时被默认地改写为 <code>globalThis</code>，这个行为现在已被移除</li></ul></li><li><a href="https://github.com/vitejs/vite/pull/14231" target="_blank" rel="noreferrer">[#14231] feat!: add extension to internal virtual modules</a><ul><li>内置虚拟模块的 id 现在包含一个扩展名（<code>.js</code>）</li></ul></li><li><a href="https://github.com/vitejs/vite/pull/14583" target="_blank" rel="noreferrer">[#14583] refactor!: remove exporting internal APIs</a><ul><li>移除意外导出的内部 API：<code>isDepsOptimizerEnabled</code> 和 <code>getDepOptimizationConfig</code></li><li>移除导出的内部类型：<code>DepOptimizationResult</code>，<code>DepOptimizationProcessing</code> 和 <code>DepsOptimizer</code></li><li>改名 <code>ResolveWorkerOptions</code> 类型为 <code>ResolvedWorkerOptions</code></li></ul></li><li><a href="https://github.com/vitejs/vite/pull/5657" target="_blank" rel="noreferrer">[#5657] fix: return 404 for resources requests outside the base path</a><ul><li>过去，Vite 对于不带 <code>Accept: text/html</code> 的请求，会将其当作带有基础路径的请求来处理。现在 Vite 不再这样做，而是返回 404。</li></ul></li><li><a href="https://github.com/vitejs/vite/pull/14723" target="_blank" rel="noreferrer">[#14723] fix(resolve)!: remove special .mjs handling</a><ul><li>在过去，当一个库的 <code>&quot;exports&quot;</code> 字段映射到一个 <code>.mjs</code> 文件时，Vite 仍然会尝试匹配 <code>&quot;browser&quot;</code> 和 <code>&quot;module&quot;</code> 字段，以修复与某些库的兼容性。现在，这种行为已被移除，以便与导出解析算法保持一致。</li></ul></li><li><a href="https://github.com/vitejs/vite/pull/14733" target="_blank" rel="noreferrer">[#14733] feat(resolve)!: remove <code>resolve.browserField</code></a><ul><li><code>resolve.browserField</code> 已从 Vite 3 开始被弃用，而是使用 <a href="/config/shared-options.html#resolve-mainfields"><code>resolve.mainFields</code></a> 的更新默认值 <code>[&#39;browser&#39;, &#39;module&#39;, &#39;jsnext:main&#39;, &#39;jsnext&#39;]</code>。</li></ul></li><li><a href="https://github.com/vitejs/vite/pull/14855" target="_blank" rel="noreferrer">[#14855] feat!: add isPreview to ConfigEnv and resolveConfig</a><ul><li>在 <code>ConfigEnv</code> 对象中，重命名 <code>ssrBuild</code> 为 <code>isSsrBuild</code>。</li></ul></li><li><a href="https://github.com/vitejs/vite/pull/14945" target="_blank" rel="noreferrer">[#14945] fix(css): correctly set manifest source name and emit CSS file</a><ul><li>CSS 文件名现在是基于 chunk 名生成的。</li></ul></li></ul><h2 id="migration-from-v3" tabindex="-1">从 v3 迁移 <a class="header-anchor" href="#migration-from-v3" aria-label="Permalink to “从 v3 迁移”">​</a></h2><p>请先查看 <a href="/guide/migration-from-v3.html">从 v3 迁移指南</a> 文档查看对您的应用所有需要迁移的改动，然后再执行本篇指南所述的改动。</p>`,70)])])}const g=i(l,[["render",o]]);export{k as __pageData,g as default};
