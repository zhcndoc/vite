import{_ as l,b as t,o as p,i as h,R as n,aS as k,j as a,S as i,g as r}from"./chunks/framework.Caqowgrb.js";const F=JSON.parse('{"title":"环境 API","description":"","frontmatter":{},"headers":[],"relativePath":"guide/api-environment.md","filePath":"guide/api-environment.md"}'),d={name:"guide/api-environment.md"};function o(E,s,g,c,y,u){const e=t("NonInheritBadge");return p(),h("div",null,[s[18]||(s[18]=n('<h1 id="environment-api" tabindex="-1">环境 API <a class="header-anchor" href="#environment-api" aria-label="Permalink to “环境 API”">​</a></h1><div class="info custom-block"><p class="custom-block-title">发布候选版本</p><p>环境 API 目前处于发布候选阶段。我们将在主要版本发布之间保持 API 的稳定性，以便生态系统能够进行实验并在此基础上进行开发。然而，请注意，<a href="/changes/#considering">某些特定的 API</a> 仍被视为实验性 API。</p><p>我们计划在未来主要版本发布时，待下游项目有足够时间对新功能进行实验并验证后，对这些新 API（可能包含兼容性变更）进行稳定化处理。</p><p>资料：</p><ul><li><a href="https://github.com/vitejs/vite/discussions/16358" target="_blank" rel="noreferrer">反馈讨论</a> 我们在此处收集新 API 的反馈。</li><li><a href="https://github.com/vitejs/vite/pull/16471" target="_blank" rel="noreferrer">环境 API PR</a> 新 API 在此处被实现并进行了审查。</li></ul><p>请与我们分享您的反馈。</p></div><h2 id="formalizing-environments" tabindex="-1">引入环境概念 <a class="header-anchor" href="#formalizing-environments" aria-label="Permalink to “引入环境概念”">​</a></h2><p>Vite 6 正式引入了“环境”的概念。在 Vite 5 之前，系统中存在两个隐式环境（<code>client</code> 和可选的 <code>ssr</code>）。新的环境 API 允许用户和框架作者根据应用在生产环境中的运行方式，创建任意数量的环境。这一新功能需要进行大规模的内部重构，但我们已投入大量精力确保向后兼容性。Vite 6 的初始目标是尽可能平滑地将生态系统迁移到新版本，推迟 API 的采用，直到足够多的用户完成迁移，且框架和插件作者已验证新设计。</p><h2 id="closing-the-gap-between-build-and-dev" tabindex="-1">缩小构建和开发模式间的差距 <a class="header-anchor" href="#closing-the-gap-between-build-and-dev" aria-label="Permalink to “缩小构建和开发模式间的差距”">​</a></h2><p>对于简单的 SPA/MPA，配置中不会暴露任何与环境有关的新 API。在内部，Vite 会将选项应用于 <code>client</code> 环境，但在配置 Vite 时无需了解这一概念。Vite 5 中的配置和行为应能在此无缝运行。</p><p>当我们移动到一个典型的服务器端渲染（SSR）应用程序时，我们将有两个环境：</p><ul><li><code>client</code>: 在浏览器中运行应用程序。</li><li><code>ssr</code>: 在 node（或其他服务器运行时）中运行应用程序，渲染页面后再发送到浏览器。</li></ul><p>在开发过程中，Vite 会在与 Vite 开发服务器相同的 Node 进程中执行服务器代码，从而接近生产环境。不过，服务器也有可能在其他 JS 运行时中运行，如 <a href="https://github.com/cloudflare/workerd" target="_blank" rel="noreferrer">Cloudflare 的 workerd</a>，它们有不同的限制。现代应用程序也可能在两个以上的环境中运行，例如浏览器、节点服务器和边缘服务器。Vite 5 无法正确表示这些环境。</p><p>Vite 6 允许用户在构建和开发过程中配置应用程序，以映射其所有环境。在开发期间，一个 Vite 开发服务器现在可用于在多个不同环境中同时运行代码。应用程序源代码仍由 Vite 开发服务器进行转换。在共享 HTTP 服务器、中间件、解析配置和插件管道的基础上，Vite 开发服务器现在拥有一组独立的开发环境。每个开发环境的配置都尽可能与生产环境相匹配，并连接到执行代码的开发运行时（对于 Workerd，服务器代码现在可以在本地 miniflare 中运行）。在客户端，浏览器导入并执行代码。在其他环境中，模块运行程序会获取并评估转换后的代码。</p><p><img src="'+k+`" alt="Vite Environments" width="1110" height="1187"></p><h2 id="environments-configuration" tabindex="-1">环境配置 <a class="header-anchor" href="#environments-configuration" aria-label="Permalink to “环境配置”">​</a></h2><p>对于 SPA/MPA，配置与 Vite 5 类似。在内部，这些选项用于配置 <code>client</code> 环境。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  build: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sourcemap: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  optimizeDeps: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    include: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;lib&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>这一点很重要，因为我们希望 Vite 保持平易近人，避免在需要时才公开新概念。</p><p>如果应用程序由多个环境组成，则可以使用 <code>environments</code> 配置选项显式配置这些环境。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  build: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sourcemap: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  optimizeDeps: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    include: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;lib&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  environments: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    server: {},</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    edge: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      resolve: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        noExternal: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div>`,17)),a("p",null,[s[0]||(s[0]=i("如果没有明确说明，环境将继承已配置的顶级配置选项（例如，新的 ",-1)),s[1]||(s[1]=a("code",null,"server",-1)),s[2]||(s[2]=i(" 和 ",-1)),s[3]||(s[3]=a("code",null,"edge",-1)),s[4]||(s[4]=i(" 环境将继承 ",-1)),s[5]||(s[5]=a("code",null,"build.sourcemap: false",-1)),s[6]||(s[6]=i(" 选项）。少数顶级选项（如 ",-1)),s[7]||(s[7]=a("code",null,"optimizeDeps",-1)),s[8]||(s[8]=i("）仅适用于 ",-1)),s[9]||(s[9]=a("code",null,"client",-1)),s[10]||(s[10]=i(" 环境，因为它们在默认应用于服务器环境时效果不佳。这些选项在",-1)),s[11]||(s[11]=a("a",{href:"/config/"},"配置参考",-1)),s[12]||(s[12]=i("中带有 ",-1)),r(e),s[13]||(s[13]=i(" 标记。也可以通过 ",-1)),s[14]||(s[14]=a("code",null,"environments.client",-1)),s[15]||(s[15]=i(" 明确配置 ",-1)),s[16]||(s[16]=a("code",null,"client",-1)),s[17]||(s[17]=i(" 环境，但我们建议使用顶级选项进行配置，以便在添加新环境时客户端配置保持不变。",-1))]),s[19]||(s[19]=n(`<p><code>EnvironmentOptions</code> 接口公开所有每个环境选项。有些环境选项适用于 <code>build</code> 和 <code>dev</code>，如 <code>resolve</code>。还有 <code>DevEnvironmentOptions</code> 和 <code>BuildEnvironmentOptions</code> 用于开发和构建特定选项（如 <code>dev.warmup</code> 或 <code>build.outDir</code>）。一些选项（例如<code>optimizeDeps</code>）仅适用于 dev，但为了向后兼容，它保留为顶层而不是嵌套在<code>dev</code>中。</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EnvironmentOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  define</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Record</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  resolve</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EnvironmentResolveOptions</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  optimizeDeps</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DepOptimizationOptions</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  consumer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;client&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;server&#39;</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  dev</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DevOptions</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  build</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BuildOptions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>UserConfig</code> 接口从 <code>EnvironmentOptions</code> 接口扩展而来，允许通过 <code>environments</code> 选项配置客户端和其他环境的默认值。在开发过程中，名为 <code>ssr</code> 的 <code>client</code> 和服务器环境始终存在。这允许与 <code>server.ssrLoadModule(url)</code> 和 <code>server.moduleGraph</code> 向后兼容。在构建期间，<code>client</code> 环境始终存在，而 <code>ssr</code> 环境仅在明确配置时才存在（使用 <code>environments.ssr</code> 或为了向后兼容而使用 <code>build.ssr</code>）。应用程序不需要为其 SSR 环境使用 <code>ssr</code> 名称，例如，它可以将其命名为 <code>server</code>。</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UserConfig</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EnvironmentOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  environments</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Record</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">EnvironmentOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 其他选项</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>请注意，一旦环境 API 稳定， <code>ssr</code> 顶级属性将被废弃。该选项的作用与 <code>environments</code> 相同，但针对的是默认的 <code>ssr</code> 环境，而且只允许配置一小部分选项。</p><h2 id="custom-environment-instances" tabindex="-1">自定义环境实例 <a class="header-anchor" href="#custom-environment-instances" aria-label="Permalink to “自定义环境实例”">​</a></h2><p>底层 API 配置已可用，因此可以支持为运行时提供环境。这些环境还可以生成其他进程或线程，以便在更接近生产环境的运行时间内运行开发模块。</p><p>例如，<a href="https://developers.cloudflare.com/workers/vite-plugin/" target="_blank" rel="noreferrer">Cloudflare Vite 插件</a> 使用环境 API 在开发过程中在 Cloudflare Workers 运行时 (<code>workerd</code>) 中运行代码。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { customEnvironment } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vite-environment-provider&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  build: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    outDir: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/dist/client&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  environments: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ssr: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">customEnvironment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      build: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        outDir: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/dist/ssr&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="backward-compatibility" tabindex="-1">向后兼容性 <a class="header-anchor" href="#backward-compatibility" aria-label="Permalink to “向后兼容性”">​</a></h2><p>当前的 Vite 服务器 API 尚未被弃用，并且与 Vite 5 向后兼容。</p><p><code>server.moduleGraph</code> 返回客户端和服务器端渲染（ssr）模块图的混合视图。所有其方法都将返回向后兼容的混合模块节点。对于传递给 <code>handleHotUpdate</code> 的模块节点，也使用相同的方案。</p><p>我们不建议现在就切换到环境 API。我们的目标是在插件不需要维护两个版本之前，让大部分用户基础采用 Vite 6。查看未来破坏性更改部分以获取未来弃用和升级路径的信息：</p><ul><li><a href="/changes/this-environment-in-hooks">钩子函数中的 <code>this.environment</code></a></li><li><a href="/changes/hotupdate-hook">HMR <code>hotUpdate</code> 插件钩子</a></li><li><a href="/changes/per-environment-apis">迁移到基于环境的API</a></li><li><a href="/changes/ssr-using-modulerunner">使用 <code>ModuleRunner</code> API 进行服务端渲染</a></li><li><a href="/changes/shared-plugins-during-build">构建过程中的共享插件</a></li></ul><h2 id="target-users" tabindex="-1">目标用户 <a class="header-anchor" href="#target-users" aria-label="Permalink to “目标用户”">​</a></h2><p>本指南为终端用户提供了关于环境的基本概念。</p><p>插件作者可以使用更一致的 API 与当前环境配置进行交互。如果你正在基于 Vite 进行开发，<a href="./api-environment-plugins">环境 API 插件指南</a> 描述了扩展插件 API 如何支持多个自定义环境。</p><p>框架可以自行决定在不同层次上暴露环境。如果你是框架作者，请继续阅读 <a href="./api-environment-frameworks">环境 API 框架指南</a>，以了解环境 API 编程方面的内容。</p><p>对于运行时提供者，<a href="./api-environment-runtimes">环境 API 运行时指南</a> 解释了如何提供自定义环境供框架和用户使用。</p>`,19))])}const v=l(d,[["render",o]]);export{F as __pageData,v as default};
